<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arcade Matrix</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600&family=Rajdhani:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: dark;
        --bg: #05070d;
        --accent-primary: #0ff0fc;
        --accent-secondary: #ff4de1;
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.65);
        --panel-bg: rgba(5, 7, 13, 0.82);
        --panel-border: rgba(15, 240, 252, 0.35);
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        min-height: 100%;
        font-family: "Rajdhani", system-ui, sans-serif;
        color: var(--text);
        background: radial-gradient(circle at center, rgba(15, 240, 252, 0.12), transparent 55%),
          radial-gradient(circle at 20% 20%, rgba(255, 77, 225, 0.18), transparent 40%), var(--bg);
        overflow: hidden;
      }

      a {
        color: inherit;
      }

      canvas {
        display: block;
      }

      #scene-container {
        position: fixed;
        inset: 0;
        overflow: hidden;
      }

      #overlay {
        position: fixed;
        inset: 0;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 1.5rem;
        z-index: 10;
      }

      #ui-top {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 1rem;
      }

      #intro-text {
        position: relative;
        align-self: center;
        margin-top: clamp(1.5rem, 9vh, 7rem);
        font-family: "Orbitron", system-ui, sans-serif;
        font-size: clamp(1.45rem, 2.5vw + 1rem, 3.1rem);
        letter-spacing: 0.18em;
        text-transform: uppercase;
        color: #90ffd7;
        text-shadow: 0 0 0.4rem rgba(79, 255, 210, 0.65), 0 0 1.6rem rgba(15, 240, 252, 0.45);
        opacity: 0;
        transform: translateY(36px) scaleY(1.08);
        filter: blur(6px);
        animation: introTextEnter 2.9s cubic-bezier(0.19, 1, 0.22, 1) 0.8s forwards,
          introTextPulse 4.2s ease-in-out 3.4s infinite;
        pointer-events: none;
        white-space: nowrap;
        text-align: center;
        mix-blend-mode: screen;
      }

      #intro-text span {
        color: var(--accent-primary);
      }

      #intro-text::after {
        content: "";
        position: absolute;
        inset: 55% -20% auto -20%;
        height: 2px;
        background: linear-gradient(90deg, transparent, rgba(144, 255, 215, 0.7), transparent);
        opacity: 0;
        transform: translateY(-8px) scaleX(0.6);
        animation: introSweep 2.4s ease-out 0.8s forwards;
      }

      .neon-button {
        pointer-events: auto;
        background: linear-gradient(120deg, rgba(15, 240, 252, 0.15), rgba(255, 77, 225, 0.1));
        border: 1px solid var(--panel-border);
        border-radius: 999px;
        color: var(--text);
        font-family: "Orbitron", system-ui, sans-serif;
        font-size: 0.95rem;
        letter-spacing: 0.1em;
        text-transform: uppercase;
        padding: 0.75rem 1.5rem;
        cursor: pointer;
        transition: transform 180ms ease, box-shadow 180ms ease;
        box-shadow: 0 0 0.75rem rgba(15, 240, 252, 0.25);
        text-decoration: none;
      }

      .neon-button:hover,
      .neon-button:focus-visible {
        transform: translateY(-2px);
        box-shadow: 0 0 1.5rem rgba(255, 77, 225, 0.4);
        outline: none;
      }

      #info-panel {
        pointer-events: auto;
        align-self: center;
        margin-top: auto;
        max-width: min(32rem, 90vw);
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        border-radius: 16px;
        padding: 1.75rem;
        backdrop-filter: blur(16px);
        box-shadow: 0 1rem 3rem rgba(0, 0, 0, 0.45);
        display: none;
      }

      #info-panel.visible {
        display: block;
      }

      #info-panel h2 {
        font-family: "Orbitron", system-ui, sans-serif;
        letter-spacing: 0.08em;
        font-size: 1.45rem;
        margin: 0 0 0.5rem;
      }

      #info-panel p {
        margin: 0 0 1.25rem;
        color: var(--muted);
        line-height: 1.5;
      }

      #info-prompt {
        margin: 0 0 1.5rem;
        font-family: "Orbitron", system-ui, sans-serif;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.8);
      }

      #info-prompt:empty {
        display: none;
      }

      #info-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      #play-button {
        background: linear-gradient(120deg, rgba(15, 240, 252, 0.35), rgba(255, 77, 225, 0.4));
        border: 1px solid rgba(15, 240, 252, 0.6);
        border-radius: 12px;
        padding: 0.75rem 1.75rem;
        font-family: "Orbitron", system-ui, sans-serif;
        font-size: 0.95rem;
        letter-spacing: 0.08em;
        cursor: pointer;
        text-decoration: none;
        color: var(--text);
        transition: transform 200ms ease, box-shadow 200ms ease;
      }

      #play-button:hover,
      #play-button:focus-visible {
        transform: translateY(-2px);
        box-shadow: 0 0 1.5rem rgba(15, 240, 252, 0.55);
        outline: none;
      }

      #close-panel {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.25);
        color: var(--muted);
        border-radius: 12px;
        padding: 0.7rem 1.25rem;
        cursor: pointer;
        font-size: 0.85rem;
        letter-spacing: 0.06em;
      }

      #instruction {
        pointer-events: none;
        font-size: 0.8rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.6);
        text-shadow: 0 0 0.5rem rgba(15, 240, 252, 0.35);
      }

      #fallback-message,
      #mobile-fallback {
        position: fixed;
        inset: 0;
        padding: clamp(1.5rem, 5vw, 3rem);
        display: none;
        flex-direction: column;
        gap: 1.5rem;
        background: rgba(5, 7, 13, 0.94);
        color: var(--text);
        overflow-y: auto;
        z-index: 20;
      }

      #fallback-message.visible,
      #mobile-fallback.visible {
        display: flex;
      }

      .fallback-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(14rem, 1fr));
        gap: 1rem;
      }

      .fallback-card {
        background: rgba(10, 14, 24, 0.85);
        border: 1px solid rgba(15, 240, 252, 0.3);
        border-radius: 14px;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .fallback-card h3 {
        margin: 0;
        font-family: "Orbitron", system-ui, sans-serif;
        font-size: 1.1rem;
      }

      .fallback-card p {
        margin: 0;
        color: var(--muted);
        font-size: 0.95rem;
      }

      .fallback-card a {
        align-self: flex-start;
        font-family: "Orbitron", system-ui, sans-serif;
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        padding: 0.5rem 1rem;
        border-radius: 999px;
        border: 1px solid rgba(15, 240, 252, 0.6);
        text-decoration: none;
      }

      #scanlines {
        position: fixed;
        inset: 0;
        pointer-events: none;
        background-image: repeating-linear-gradient(
          0deg,
          rgba(0, 0, 0, 0.18) 0px,
          rgba(0, 0, 0, 0.18) 2px,
          transparent 2px,
          transparent 4px
        );
        opacity: 0.25;
        mix-blend-mode: screen;
        z-index: 1;
      }

      #scanlines::after {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          to bottom,
          transparent,
          rgba(15, 240, 252, 0.12),
          transparent
        );
        animation: scan 4.5s linear infinite;
        opacity: 0.5;
      }

      @keyframes introTextEnter {
        0% {
          opacity: 0;
          transform: translateY(60px) scaleY(1.2);
          letter-spacing: 0.45em;
          filter: blur(12px);
        }
        45% {
          opacity: 1;
          transform: translateY(0) scaleY(1);
          letter-spacing: 0.18em;
          filter: blur(0);
        }
        60% {
          opacity: 0.3;
        }
        70% {
          opacity: 1;
        }
        100% {
          opacity: 1;
          transform: translateY(0) scaleY(1);
          letter-spacing: 0.18em;
          filter: blur(0);
        }
      }

      @keyframes introTextPulse {
        0%,
        100% {
          text-shadow: 0 0 0.35rem rgba(79, 255, 210, 0.55), 0 0 1.4rem rgba(15, 240, 252, 0.4);
        }
        50% {
          text-shadow: 0 0 0.6rem rgba(144, 255, 215, 0.85), 0 0 1.8rem rgba(15, 240, 252, 0.6);
        }
      }

      @keyframes introSweep {
        0% {
          opacity: 0;
          transform: translateY(-24px) scaleX(0.3);
        }
        45% {
          opacity: 0.9;
          transform: translateY(0) scaleX(1.1);
        }
        100% {
          opacity: 0;
          transform: translateY(12px) scaleX(0.4);
        }
      }

      @keyframes scan {
        0% {
          transform: translateY(-20%);
        }
        50% {
          transform: translateY(20%);
        }
        100% {
          transform: translateY(-20%);
        }
      }

      @media (max-width: 768px) {
        body {
          overflow-y: auto;
        }
      }
    </style>
  </head>
  <body>
    <div id="scene-container"></div>
    <div id="scanlines"></div>

    <div id="overlay">
      <div id="ui-top">
        <div id="instruction">Scroll to move â€¢ Click a cabinet to explore</div>
        <a class="neon-button" href="/">Exit Arcade</a>
      </div>
      <div id="intro-text" aria-hidden="true">Games.<span>&nbsp;Lots of games.</span></div>
      <div id="info-panel" role="dialog" aria-modal="true">
        <h2 id="info-title">Cabinet Title</h2>
        <p id="info-description">Description placeholder</p>
        <p id="info-prompt" aria-live="polite"></p>
        <div id="info-actions">
          <a id="play-button" href="#" target="_blank" rel="noopener">Play</a>
          <button id="close-panel">Back to walkway</button>
        </div>
      </div>
    </div>

    <section id="fallback-message">
      <h1>Neon Arcade Requires WebGL</h1>
      <p>
        Your browser does not support WebGL, which powers the immersive arcade experience. Consider
        updating your browser or enabling hardware acceleration to step inside the grid.
      </p>
    </section>

    <section id="mobile-fallback">
      <h1>Arcade Cabinet Directory</h1>
      <p>
        The full 3D arcade is best experienced on desktop. Use this directory to jump into games on
        mobile.
      </p>
      <div class="fallback-grid" id="fallback-grid"></div>
      <a class="neon-button" href="/">Exit Arcade</a>
    </section>

    <noscript>
      <section id="fallback-noscript" style="padding: 2rem; color: white;">
        <h1>JavaScript Disabled</h1>
        <p>
          Enable JavaScript to access the interactive arcade selection. You can still view game
          repositories from the project homepage.
        </p>
      </section>
    </noscript>

    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.157.0/build/three.module.js';

      const sceneContainer = document.getElementById('scene-container');
      const fallbackMessage = document.getElementById('fallback-message');
      const mobileFallback = document.getElementById('mobile-fallback');
      const fallbackGrid = document.getElementById('fallback-grid');
      const infoPanel = document.getElementById('info-panel');
      const infoTitle = document.getElementById('info-title');
      const infoDescription = document.getElementById('info-description');
      const infoPrompt = document.getElementById('info-prompt');
      const playButton = document.getElementById('play-button');
      const closePanelButton = document.getElementById('close-panel');

      const supportsWebGL = (() => {
        try {
          const canvas = document.createElement('canvas');
          return !!(
            window.WebGLRenderingContext &&
            (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))
          );
        } catch (err) {
          return false;
        }
      })();

      const coarsePointerQuery = window.matchMedia('(pointer: coarse)');

      function shouldUseMobileLayout() {
        return coarsePointerQuery.matches || window.innerWidth < 768;
      }

      let layoutMode = null;
      let arcadeHasInitialized = false;
      let arcadeCleanup = null;

      const games = [
        // Add new cabinets here. Each entry controls the cabinet model, its overlay content, and link.
        {
          name: 'Starship Courier',
          description: 'Deliver critical data across neon voids while dodging rogue drones and cosmic storms.',
          url: 'https://example.com/starship-courier',
          thumbnail: 'https://images.unsplash.com/photo-1511512578047-dfb367046420?auto=format&fit=crop&w=600&q=80',
        },
        {
          name: 'Circuit Breaker',
          description: 'Hack the megacorp grid before the timer hits zero in this fast-paced puzzler.',
          url: 'https://example.com/circuit-breaker',
          thumbnail: 'https://images.unsplash.com/photo-1521572267360-ee0c2909d518?auto=format&fit=crop&w=600&q=80',
        },
        {
          name: 'Ghost Signal',
          description: 'Tune into other realities and banish glitches in a haunted synthwave control room.',
          url: 'https://example.com/ghost-signal',
          thumbnail: 'https://images.unsplash.com/photo-1604079628040-94301bb21b11?auto=format&fit=crop&w=600&q=80',
        },
      ];

      function buildMobileDirectory() {
        fallbackGrid.innerHTML = '';
        games.forEach((game) => {
          const card = document.createElement('article');
          card.className = 'fallback-card';
          card.innerHTML = `
            <h3>${game.name}</h3>
            <p>${game.description}</p>
            <a href="${game.url}" target="_blank" rel="noopener">Launch</a>
          `;
          fallbackGrid.appendChild(card);
        });
        mobileFallback.classList.add('visible');
      }

      function maybeToggleLayout() {
        if (!supportsWebGL) return;

        fallbackMessage.classList.remove('visible');

        const useMobileLayout = shouldUseMobileLayout();

        if (useMobileLayout) {
          if (layoutMode === 'arcade' && typeof arcadeCleanup === 'function') {
            arcadeCleanup();
            arcadeCleanup = null;
          }

          infoPanel.classList.remove('visible');
          infoPrompt.textContent = '';
          buildMobileDirectory();
          mobileFallback.classList.add('visible');
          layoutMode = 'mobile';
          return;
        }

        mobileFallback.classList.remove('visible');

        if (layoutMode !== 'arcade' || !sceneContainer.firstChild) {
          if (!arcadeHasInitialized || !sceneContainer.firstChild) {
            arcadeCleanup = initArcade();
            arcadeHasInitialized = true;
          }
          layoutMode = 'arcade';
        }
      }

      const handlePointerPreferenceChange = () => maybeToggleLayout();

      if (!supportsWebGL) {
        fallbackMessage.classList.add('visible');
      } else {
        maybeToggleLayout();

        if (typeof coarsePointerQuery.addEventListener === 'function') {
          coarsePointerQuery.addEventListener('change', handlePointerPreferenceChange);
        } else if (typeof coarsePointerQuery.addListener === 'function') {
          coarsePointerQuery.addListener(handlePointerPreferenceChange);
        }

        window.addEventListener('resize', maybeToggleLayout);
      }

      function initArcade() {
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;
        sceneContainer.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x03060d);
        scene.fog = new THREE.FogExp2(0x03060d, 0.035);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 120);
        const CAMERA_START_POSITION = new THREE.Vector3(0, 2.4, 0);
        // Keep the camera height controlled solely by the rig so it remains at 2.4m
        // when focusing on a cabinet.
        camera.position.set(0, 0, 0);

        const cameraRig = new THREE.Group();
        cameraRig.position.copy(CAMERA_START_POSITION);
        cameraRig.add(camera);
        scene.add(cameraRig);

        const DEFAULT_LOOK_TARGET = new THREE.Vector3(0, 2.4, -999);
        const lookTarget = DEFAULT_LOOK_TARGET.clone();
        const desiredLookTarget = DEFAULT_LOOK_TARGET.clone();

        const ambientLight = new THREE.AmbientLight(0x1f2438, 1.4);
        scene.add(ambientLight);

        const hemi = new THREE.HemisphereLight(0x2188ff, 0x05070d, 0.7);
        scene.add(hemi);

        const spotLeft = new THREE.SpotLight(0x0ff0fc, 2.4, 45, Math.PI / 4, 0.7, 1.2);
        spotLeft.position.set(-8, 6, 2);
        scene.add(spotLeft);

        const spotRight = new THREE.SpotLight(0xff4de1, 2.3, 45, Math.PI / 4, 0.7, 1.2);
        spotRight.position.set(8, 6, -4);
        scene.add(spotRight);

        const floorGeometry = new THREE.PlaneGeometry(60, 200, 32, 32);
        const floorMaterial = new THREE.MeshStandardMaterial({
          color: 0x050a1a,
          metalness: 0.2,
          roughness: 0.6,
          emissive: 0x021627,
          emissiveIntensity: 0.5,
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.01;
        scene.add(floor);

        const gridHelper = new THREE.GridHelper(80, 80, 0x0ff0fc, 0x082637);
        gridHelper.position.y = 0.001;
        scene.add(gridHelper);

        const textureLoader = new THREE.TextureLoader();
        textureLoader.crossOrigin = 'anonymous';

        const cabinetGroup = new THREE.Group();
        scene.add(cabinetGroup);

        const cabinets = [];
        const introAnimations = [];
        let introClockStart = null;
        let introDone = false;
        const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
        const spacing = 6.5;
        const laneOffset = 5.5;
        const startZ = -7;

        games.forEach((game, index) => {
          const side = index % 2 === 0 ? 'left' : 'right';
          const cabinet = createCabinet(game, side, index);
          const x = side === 'left' ? -laneOffset : laneOffset;
          const z = startZ - index * spacing;
          const finalPosition = new THREE.Vector3(x, 0, z);
          cabinet.position.copy(finalPosition);
          cabinet.rotation.y = side === 'left' ? Math.PI / 2 : -Math.PI / 2;
          cabinet.userData.focusPosition = new THREE.Vector3(0, CAMERA_START_POSITION.y, z);
          cabinet.userData.restPosition = finalPosition.clone();

          const slideOffset = side === 'left' ? -12 : 12;
          const fromX = finalPosition.x + slideOffset;
          cabinet.position.x = fromX;
          const pairIndex = Math.floor(index / 2);
          const delay = pairIndex * 240 + (side === 'left' ? 0 : 120);
          introAnimations.push({
            cabinet,
            fromX,
            toX: finalPosition.x,
            delay,
            duration: 1300,
            done: false,
          });

          cabinetGroup.add(cabinet);

          cabinets.push(cabinet);
        });

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let hoverCabinet = null;
        let pendingHoverCabinet = null;
        let hoverLockState = 'idle';
        let hoverLockUntil = 0;
        const HOVER_LOCK_HOLD_MS = 200;
        const LOOK_TARGET_SETTLED_EPSILON = 0.05;
        let activeCabinet = null;
        let approachingCabinet = null;
        let targetZ = cameraRig.position.z;
        let scrollVelocity = 0;
        const lastCabinetZ = startZ - (games.length - 1) * spacing;
        const minZ = lastCabinetZ - 4;
        const maxZ = 12;
        const walkwayReturnPosition = new THREE.Vector3(0, CAMERA_START_POSITION.y, cameraRig.position.z);
        const focusRigTarget = new THREE.Vector3();
        const rigGoal = new THREE.Vector3();
        const APPROACH_ALIGNMENT_EPSILON = 0.12;

        const emissivePulse = new THREE.Color(0x0ff0fc);
        const tempColor = new THREE.Color();

        const onWheel = (event) => {
          if (!introDone) return;
          if (activeCabinet || approachingCabinet) return;
          scrollVelocity += event.deltaY * 0.025;
        };

        window.addEventListener('wheel', onWheel, { passive: true });

        const onPointerMove = (event) => {
          if (!introDone) return;
          const rect = renderer.domElement.getBoundingClientRect();
          pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
          if (activeCabinet || approachingCabinet) return;
          raycaster.setFromCamera(pointer, camera);
          const intersects = raycaster.intersectObjects(cabinets, true);
          let candidate = intersects.length ? intersects[0].object : null;
          while (candidate && !cabinets.includes(candidate)) {
            candidate = candidate.parent;
          }
          pendingHoverCabinet = candidate && cabinets.includes(candidate) ? candidate : null;
          const now = performance.now();
          if (hoverLockState === 'idle') {
            applyHoverSelection(pendingHoverCabinet);
          } else if (hoverLockState === 'hold' && now >= hoverLockUntil) {
            hoverLockState = 'idle';
            applyHoverSelection(pendingHoverCabinet);
          }
        };

        renderer.domElement.addEventListener('pointermove', onPointerMove);

        const onPointerLeave = () => {
          if (!introDone) return;
          if (activeCabinet || approachingCabinet) return;
          pendingHoverCabinet = null;
          if (hoverLockState === 'idle') {
            applyHoverSelection(null);
          } else if (hoverLockState === 'hold' && performance.now() >= hoverLockUntil) {
            hoverLockState = 'idle';
            applyHoverSelection(null);
          }
        };

        renderer.domElement.addEventListener('pointerleave', onPointerLeave);

        const onRendererClick = () => {
          if (!introDone) return;
          if (hoverCabinet && !activeCabinet && !approachingCabinet) {
            focusCabinet(hoverCabinet);
          }
        };

        renderer.domElement.addEventListener('click', onRendererClick);

        const onClosePanelClick = () => {
          exitCabinetView();
        };

        closePanelButton.addEventListener('click', onClosePanelClick);

        const onKeyDown = (event) => {
          if (event.key === 'Escape') {
            exitCabinetView();
          }
        };

        window.addEventListener('keydown', onKeyDown);

        function focusCabinet(cabinet) {
          if (!introDone) return;
          walkwayReturnPosition.set(0, CAMERA_START_POSITION.y, cameraRig.position.z);
          resetHoverState();
          hoverCabinet = cabinet;
          approachingCabinet = cabinet;
          focusRigTarget.set(0, CAMERA_START_POSITION.y, cabinet.userData.focusPosition.z);
          targetZ = focusRigTarget.z;
          scrollVelocity = 0;
          activeCabinet = null;
          infoTitle.textContent = cabinet.userData.game.name;
          infoDescription.textContent = cabinet.userData.game.description;
          infoPrompt.textContent = `Ready to play ${cabinet.userData.game.name}?`;
          playButton.href = cabinet.userData.game.url;
          infoPanel.classList.remove('visible');
          renderer.domElement.style.cursor = 'default';
        }

        const onPlayButtonClick = (event) => {
          event.preventDefault();
          const gameUrl = playButton.href;

          const cabinetX = activeCabinet ? activeCabinet.position.x : 0;
          const moveDistance = 3;

          if (cabinetX < 0) {
            focusRigTarget.x -= moveDistance;
          } else {
            focusRigTarget.x += moveDistance;
          }

          setTimeout(() => {
            window.open(gameUrl, '_blank', 'noopener');
          }, 800);
        };

        playButton.addEventListener('click', onPlayButtonClick);

        function exitCabinetView() {
          if (!activeCabinet && !approachingCabinet) return;
          activeCabinet = null;
          approachingCabinet = null;
          resetHoverState();
          infoPanel.classList.remove('visible');
          infoPrompt.textContent = '';
          targetZ = walkwayReturnPosition.z;
        }


        function applyHoverSelection(cabinet) {
          if (hoverCabinet === cabinet) return;
          hoverCabinet = cabinet;
          if (hoverCabinet) {
            hoverLockState = 'panning';
            hoverLockUntil = 0;
          } else {
            hoverLockState = 'idle';
            hoverLockUntil = 0;
          }
          renderer.domElement.style.cursor = hoverCabinet ? 'pointer' : 'default';
        }

        function resetHoverState() {
          hoverCabinet = null;
          pendingHoverCabinet = null;
          hoverLockState = 'idle';
          hoverLockUntil = 0;
          renderer.domElement.style.cursor = 'default';
        }

        function updateCabinetEmissive() {
          const pulse = (Math.sin(performance.now() * 0.003) + 1) * 0.35 + 0.4;
          cabinets.forEach((cabinet) => {
            const screen = cabinet.getObjectByName('screen');
            if (!screen) return;
            if (cabinet === hoverCabinet && !activeCabinet) {
              screen.material.emissive = emissivePulse.clone().multiplyScalar(0.7);
            } else {
              tempColor.copy(emissivePulse).multiplyScalar(pulse * 0.6);
              screen.material.emissive = tempColor;
            }
          });
        }

        function createCabinet(game, side, index) {
          const cabinet = new THREE.Group();
          cabinet.userData.game = game;

          const bodyGeometry = new THREE.BoxGeometry(2.6, 3.8, 2.2);
          const bodyMaterial = new THREE.MeshStandardMaterial({
            color: side === 'left' ? 0x09122b : 0x1a0622,
            metalness: 0.4,
            roughness: 0.6,
            emissive: side === 'left' ? 0x053754 : 0x24032f,
            emissiveIntensity: 0.35,
          });
          const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
          body.position.y = 1.7;
          cabinet.add(body);

          const marqueeGeometry = new THREE.BoxGeometry(2.4, 0.6, 0.3);
          const marqueeMaterial = new THREE.MeshStandardMaterial({
            color: 0x0ff0fc,
            emissive: 0x0ff0fc,
            emissiveIntensity: 0.9,
          });
          const marquee = new THREE.Mesh(marqueeGeometry, marqueeMaterial);
          marquee.position.set(0, 3.5, 0.8);
          cabinet.add(marquee);

          const screenGeometry = new THREE.BoxGeometry(1.9, 1.4, 0.2);
          const screenMaterial = new THREE.MeshStandardMaterial({
            color: 0x05090f,
            emissive: 0x000000,
            emissiveIntensity: 0.8,
            transparent: true,
          });
          const screen = new THREE.Mesh(screenGeometry, screenMaterial);
          screen.position.set(0, 2.4, 1);
          screen.name = 'screen';
          cabinet.add(screen);

          textureLoader.load(
            game.thumbnail,
            (texture) => {
              texture.encoding = THREE.sRGBEncoding;
              texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
              const material = new THREE.MeshBasicMaterial({
                map: texture,
                toneMapped: false,
              });
              const imagePlane = new THREE.Mesh(new THREE.PlaneGeometry(1.8, 1.25), material);
              imagePlane.position.set(0, 2.4, 1.11);
              cabinet.add(imagePlane);
            },
            undefined,
            () => {
              // Texture failed to load; keep the emissive glow only.
            }
          );

          const panelGeometry = new THREE.BoxGeometry(2.2, 0.3, 1.2);
          const panelMaterial = new THREE.MeshStandardMaterial({
            color: 0x04070f,
            metalness: 0.3,
            roughness: 0.7,
          });
          const controlPanel = new THREE.Mesh(panelGeometry, panelMaterial);
          controlPanel.position.set(0, 1.2, 1.2);
          controlPanel.rotation.x = -Math.PI / 12;
          cabinet.add(controlPanel);

          const neonBaseGeometry = new THREE.BoxGeometry(3.2, 0.25, 2.8);
          const neonBaseMaterial = new THREE.MeshStandardMaterial({
            color: 0x03060d,
            emissive: 0x101a2c,
            emissiveIntensity: 0.4,
          });
          const base = new THREE.Mesh(neonBaseGeometry, neonBaseMaterial);
          base.position.y = 0.12;
          cabinet.add(base);

          const accentMaterial = new THREE.MeshBasicMaterial({
            color: side === 'left' ? 0x0ff0fc : 0xff4de1,
          });
          const accentGeometry = new THREE.CylinderGeometry(0.06, 0.06, 3.6, 12);
          const accent = new THREE.Mesh(accentGeometry, accentMaterial);
          accent.position.set(side === 'left' ? 1.35 : -1.35, 1.7, 0.95);
          accent.rotation.z = Math.PI / 2.5;
          cabinet.add(accent);

          return cabinet;
        }

        let lastFrameTime = performance.now();
        let animationFrameId = 0;

        function animate() {
          animationFrameId = requestAnimationFrame(animate);
          const now = performance.now();
          const deltaSeconds = Math.min((now - lastFrameTime) / 1000, 0.1);
          lastFrameTime = now;

          if (introClockStart === null) {
            introClockStart = now;
          }

          let introActive = false;
          introAnimations.forEach((animation) => {
            if (animation.done) return;
            const elapsed = now - introClockStart - animation.delay;
            if (elapsed < 0) {
              introActive = true;
              return;
            }
            const progress = Math.min(1, elapsed / animation.duration);
            const eased = easeOutCubic(progress);
            animation.cabinet.position.x = THREE.MathUtils.lerp(animation.fromX, animation.toX, eased);
            if (progress >= 1) {
              animation.done = true;
              animation.cabinet.position.x = animation.toX;
            } else {
              introActive = true;
            }
          });

          if (!introActive && !introDone) {
            introDone = true;
          }

          const cameraLocked = approachingCabinet || activeCabinet;
          if (!cameraLocked) {
            const damping = Math.exp(-2.8 * deltaSeconds);
            scrollVelocity *= damping;
            if (Math.abs(scrollVelocity) < 0.00001) {
              scrollVelocity = 0;
            }
            targetZ += scrollVelocity * deltaSeconds;
            if (targetZ < minZ) {
              targetZ = minZ;
              scrollVelocity = Math.max(0, scrollVelocity);
            } else if (targetZ > maxZ) {
              targetZ = maxZ;
              scrollVelocity = Math.min(0, scrollVelocity);
            }
            rigGoal.set(0, CAMERA_START_POSITION.y, targetZ);
          } else {
            rigGoal.copy(focusRigTarget);
            rigGoal.y = CAMERA_START_POSITION.y;
          }

          cameraRig.position.lerp(rigGoal, 0.05);
          cameraRig.position.y = CAMERA_START_POSITION.y;
          if (!cameraLocked) {
            walkwayReturnPosition.set(0, CAMERA_START_POSITION.y, cameraRig.position.z);
          }

          if (approachingCabinet) {
            const alignmentDistance = cameraRig.position.distanceTo(focusRigTarget);
            if (alignmentDistance < APPROACH_ALIGNMENT_EPSILON) {
              activeCabinet = approachingCabinet;
              hoverCabinet = approachingCabinet;
              approachingCabinet = null;
              infoPanel.classList.add('visible');
            }
          }

          const lookTargetCabinet = activeCabinet ?? hoverCabinet;
          if (lookTargetCabinet) {
            desiredLookTarget.copy(lookTargetCabinet.position).setY(DEFAULT_LOOK_TARGET.y);
          } else {
            desiredLookTarget.set(0, DEFAULT_LOOK_TARGET.y, cameraRig.position.z - 10);
          }

          const lookLerpSpeed = activeCabinet ? 0.2 : 0.08;
          lookTarget.lerp(desiredLookTarget, lookLerpSpeed);

          if (hoverLockState === 'panning' && hoverCabinet) {
            const lookDelta = lookTarget.distanceTo(desiredLookTarget);
            if (lookDelta < LOOK_TARGET_SETTLED_EPSILON) {
              hoverLockState = 'hold';
              hoverLockUntil = now + HOVER_LOCK_HOLD_MS;
            }
          } else if (hoverLockState === 'hold' && now >= hoverLockUntil) {
            hoverLockState = 'idle';
            applyHoverSelection(pendingHoverCabinet);
          }

          camera.lookAt(lookTarget);

          updateCabinetEmissive();

          renderer.render(scene, camera);
        }

        animationFrameId = requestAnimationFrame(animate);

        const onResize = () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        };

        window.addEventListener('resize', onResize);

        return () => {
          cancelAnimationFrame(animationFrameId);
          window.removeEventListener('wheel', onWheel);
          window.removeEventListener('keydown', onKeyDown);
          window.removeEventListener('resize', onResize);
          renderer.domElement.removeEventListener('pointermove', onPointerMove);
          renderer.domElement.removeEventListener('pointerleave', onPointerLeave);
          renderer.domElement.removeEventListener('click', onRendererClick);
          playButton.removeEventListener('click', onPlayButtonClick);
          closePanelButton.removeEventListener('click', onClosePanelClick);
          renderer.domElement.style.cursor = 'default';
          infoPanel.classList.remove('visible');
          infoPrompt.textContent = '';
          if (renderer.domElement.parentElement === sceneContainer) {
            sceneContainer.removeChild(renderer.domElement);
          }

          scene.traverse((child) => {
            if (child.geometry && typeof child.geometry.dispose === 'function') {
              child.geometry.dispose();
            }

            const materials = Array.isArray(child.material)
              ? child.material
              : child.material
              ? [child.material]
              : [];

            materials.forEach((material) => {
              if (!material) return;
              if (material.map && typeof material.map.dispose === 'function') {
                material.map.dispose();
              }
              if (typeof material.dispose === 'function') {
                material.dispose();
              }
            });
          });

          renderer.dispose();
        };
      }
    </script>
  </body>
</html>
