<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arcade Matrix</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600&family=Rajdhani:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: dark;
        --bg: #05070d;
        --accent-primary: #0ff0fc;
        --accent-secondary: #ff4de1;
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.65);
        --panel-bg: rgba(5, 7, 13, 0.82);
        --panel-border: rgba(15, 240, 252, 0.35);
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        min-height: 100%;
        font-family: "Rajdhani", system-ui, sans-serif;
        color: var(--text);
        background: radial-gradient(circle at center, rgba(15, 240, 252, 0.12), transparent 55%),
          radial-gradient(circle at 20% 20%, rgba(255, 77, 225, 0.18), transparent 40%), var(--bg);
        overflow: hidden;
      }

      a {
        color: inherit;
      }

      canvas {
        display: block;
      }

      #scene-container {
        position: fixed;
        inset: 0;
        overflow: hidden;
      }

      #overlay {
        position: fixed;
        inset: 0;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 1.5rem;
        z-index: 10;
      }

      #ui-top {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 1rem;
      }

      .neon-button {
        pointer-events: auto;
        background: linear-gradient(120deg, rgba(15, 240, 252, 0.15), rgba(255, 77, 225, 0.1));
        border: 1px solid var(--panel-border);
        border-radius: 999px;
        color: var(--text);
        font-family: "Orbitron", system-ui, sans-serif;
        font-size: 0.95rem;
        letter-spacing: 0.1em;
        text-transform: uppercase;
        padding: 0.75rem 1.5rem;
        cursor: pointer;
        transition: transform 180ms ease, box-shadow 180ms ease;
        box-shadow: 0 0 0.75rem rgba(15, 240, 252, 0.25);
        text-decoration: none;
      }

      .neon-button:hover,
      .neon-button:focus-visible {
        transform: translateY(-2px);
        box-shadow: 0 0 1.5rem rgba(255, 77, 225, 0.4);
        outline: none;
      }

      #info-panel {
        pointer-events: auto;
        align-self: center;
        margin-top: auto;
        max-width: min(32rem, 90vw);
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        border-radius: 16px;
        padding: 1.75rem;
        backdrop-filter: blur(16px);
        box-shadow: 0 1rem 3rem rgba(0, 0, 0, 0.45);
        display: none;
      }

      #info-panel.visible {
        display: block;
      }

      #info-panel h2 {
        font-family: "Orbitron", system-ui, sans-serif;
        letter-spacing: 0.08em;
        font-size: 1.45rem;
        margin: 0 0 0.5rem;
      }

      #info-panel p {
        margin: 0 0 1.25rem;
        color: var(--muted);
        line-height: 1.5;
      }

      #info-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      #play-button {
        background: linear-gradient(120deg, rgba(15, 240, 252, 0.35), rgba(255, 77, 225, 0.4));
        border: 1px solid rgba(15, 240, 252, 0.6);
        border-radius: 12px;
        padding: 0.75rem 1.75rem;
        font-family: "Orbitron", system-ui, sans-serif;
        font-size: 0.95rem;
        letter-spacing: 0.08em;
        cursor: pointer;
        text-decoration: none;
        color: var(--text);
        transition: transform 200ms ease, box-shadow 200ms ease;
      }

      #play-button:hover,
      #play-button:focus-visible {
        transform: translateY(-2px);
        box-shadow: 0 0 1.5rem rgba(15, 240, 252, 0.55);
        outline: none;
      }

      #close-panel {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.25);
        color: var(--muted);
        border-radius: 12px;
        padding: 0.7rem 1.25rem;
        cursor: pointer;
        font-size: 0.85rem;
        letter-spacing: 0.06em;
      }

      #instruction {
        pointer-events: none;
        font-size: 0.8rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.6);
        text-shadow: 0 0 0.5rem rgba(15, 240, 252, 0.35);
      }

      #fallback-message,
      #mobile-fallback {
        position: fixed;
        inset: 0;
        padding: clamp(1.5rem, 5vw, 3rem);
        display: none;
        flex-direction: column;
        gap: 1.5rem;
        background: rgba(5, 7, 13, 0.94);
        color: var(--text);
        overflow-y: auto;
        z-index: 20;
      }

      #fallback-message.visible,
      #mobile-fallback.visible {
        display: flex;
      }

      .fallback-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(14rem, 1fr));
        gap: 1rem;
      }

      .fallback-card {
        background: rgba(10, 14, 24, 0.85);
        border: 1px solid rgba(15, 240, 252, 0.3);
        border-radius: 14px;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .fallback-card h3 {
        margin: 0;
        font-family: "Orbitron", system-ui, sans-serif;
        font-size: 1.1rem;
      }

      .fallback-card p {
        margin: 0;
        color: var(--muted);
        font-size: 0.95rem;
      }

      .fallback-card a {
        align-self: flex-start;
        font-family: "Orbitron", system-ui, sans-serif;
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        padding: 0.5rem 1rem;
        border-radius: 999px;
        border: 1px solid rgba(15, 240, 252, 0.6);
        text-decoration: none;
      }

      #scanlines {
        position: fixed;
        inset: 0;
        pointer-events: none;
        background-image: repeating-linear-gradient(
          0deg,
          rgba(0, 0, 0, 0.18) 0px,
          rgba(0, 0, 0, 0.18) 2px,
          transparent 2px,
          transparent 4px
        );
        opacity: 0.25;
        mix-blend-mode: screen;
        z-index: 1;
      }

      #scanlines::after {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          to bottom,
          transparent,
          rgba(15, 240, 252, 0.12),
          transparent
        );
        animation: scan 4.5s linear infinite;
        opacity: 0.5;
      }

      @keyframes scan {
        0% {
          transform: translateY(-20%);
        }
        50% {
          transform: translateY(20%);
        }
        100% {
          transform: translateY(-20%);
        }
      }

      @media (max-width: 768px) {
        body {
          overflow-y: auto;
        }
      }
    </style>
  </head>
  <body>
    <div id="scene-container"></div>
    <div id="scanlines"></div>

    <div id="overlay">
      <div id="ui-top">
        <div id="instruction">Scroll to move â€¢ Click a cabinet to explore</div>
        <a class="neon-button" href="/">Exit Arcade</a>
      </div>
      <div id="info-panel" role="dialog" aria-modal="true">
        <h2 id="info-title">Cabinet Title</h2>
        <p id="info-description">Description placeholder</p>
        <div id="info-actions">
          <a id="play-button" href="#" target="_blank" rel="noopener">Play</a>
          <button id="close-panel">Back to walkway</button>
        </div>
      </div>
    </div>

    <section id="fallback-message">
      <h1>Neon Arcade Requires WebGL</h1>
      <p>
        Your browser does not support WebGL, which powers the immersive arcade experience. Consider
        updating your browser or enabling hardware acceleration to step inside the grid.
      </p>
    </section>

    <section id="mobile-fallback">
      <h1>Arcade Cabinet Directory</h1>
      <p>
        The full 3D arcade is best experienced on desktop. Use this directory to jump into games on
        mobile.
      </p>
      <div class="fallback-grid" id="fallback-grid"></div>
      <a class="neon-button" href="/">Exit Arcade</a>
    </section>

    <noscript>
      <section id="fallback-noscript" style="padding: 2rem; color: white;">
        <h1>JavaScript Disabled</h1>
        <p>
          Enable JavaScript to access the interactive arcade selection. You can still view game
          repositories from the project homepage.
        </p>
      </section>
    </noscript>

    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.157.0/build/three.module.js';

      const sceneContainer = document.getElementById('scene-container');
      const fallbackMessage = document.getElementById('fallback-message');
      const mobileFallback = document.getElementById('mobile-fallback');
      const fallbackGrid = document.getElementById('fallback-grid');
      const infoPanel = document.getElementById('info-panel');
      const infoTitle = document.getElementById('info-title');
      const infoDescription = document.getElementById('info-description');
      const playButton = document.getElementById('play-button');
      const closePanelButton = document.getElementById('close-panel');

      const supportsWebGL = (() => {
        try {
          const canvas = document.createElement('canvas');
          return !!(
            window.WebGLRenderingContext &&
            (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))
          );
        } catch (err) {
          return false;
        }
      })();

      const prefersMobileLayout = window.matchMedia('(pointer: coarse)').matches || window.innerWidth < 768;

      const games = [
        // Add new cabinets here. Each entry controls the cabinet model, its overlay content, and link.
        {
          name: 'Starship Courier',
          description: 'Deliver critical data across neon voids while dodging rogue drones and cosmic storms.',
          url: 'https://example.com/starship-courier',
          thumbnail: 'https://images.unsplash.com/photo-1511512578047-dfb367046420?auto=format&fit=crop&w=600&q=80',
        },
        {
          name: 'Circuit Breaker',
          description: 'Hack the megacorp grid before the timer hits zero in this fast-paced puzzler.',
          url: 'https://example.com/circuit-breaker',
          thumbnail: 'https://images.unsplash.com/photo-1521572267360-ee0c2909d518?auto=format&fit=crop&w=600&q=80',
        },
        {
          name: 'Ghost Signal',
          description: 'Tune into other realities and banish glitches in a haunted synthwave control room.',
          url: 'https://example.com/ghost-signal',
          thumbnail: 'https://images.unsplash.com/photo-1604079628040-94301bb21b11?auto=format&fit=crop&w=600&q=80',
        },
      ];

      function buildMobileDirectory() {
        fallbackGrid.innerHTML = '';
        games.forEach((game) => {
          const card = document.createElement('article');
          card.className = 'fallback-card';
          card.innerHTML = `
            <h3>${game.name}</h3>
            <p>${game.description}</p>
            <a href="${game.url}" target="_blank" rel="noopener">Launch</a>
          `;
          fallbackGrid.appendChild(card);
        });
        mobileFallback.classList.add('visible');
      }

      if (!supportsWebGL) {
        fallbackMessage.classList.add('visible');
      } else if (prefersMobileLayout) {
        buildMobileDirectory();
      } else {
        initArcade();
      }

      function initArcade() {
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;
        sceneContainer.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x03060d);
        scene.fog = new THREE.FogExp2(0x03060d, 0.035);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 120);
        camera.position.set(0, 1.6, 12);

        const cameraRig = new THREE.Group();
        cameraRig.position.set(0, 1.6, 12);
        cameraRig.add(camera);
        scene.add(cameraRig);

        const lookTarget = new THREE.Vector3(0, 1.5, -5);
        const desiredLookTarget = lookTarget.clone();

        const ambientLight = new THREE.AmbientLight(0x1f2438, 1.4);
        scene.add(ambientLight);

        const hemi = new THREE.HemisphereLight(0x2188ff, 0x05070d, 0.7);
        scene.add(hemi);

        const spotLeft = new THREE.SpotLight(0x0ff0fc, 2.5, 45, Math.PI / 4, 0.7, 1.2);
        spotLeft.position.set(-8, 6, 2);
        scene.add(spotLeft);

        const spotRight = new THREE.SpotLight(0xff4de1, 2.3, 45, Math.PI / 4, 0.7, 1.2);
        spotRight.position.set(8, 6, -4);
        scene.add(spotRight);

        const floorGeometry = new THREE.PlaneGeometry(60, 200, 32, 32);
        const floorMaterial = new THREE.MeshStandardMaterial({
          color: 0x050a1a,
          metalness: 0.2,
          roughness: 0.6,
          emissive: 0x021627,
          emissiveIntensity: 0.5,
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.01;
        scene.add(floor);

        const gridHelper = new THREE.GridHelper(80, 80, 0x0ff0fc, 0x082637);
        gridHelper.position.y = 0.001;
        scene.add(gridHelper);

        const textureLoader = new THREE.TextureLoader();
        textureLoader.crossOrigin = 'anonymous';

        const cabinetGroup = new THREE.Group();
        scene.add(cabinetGroup);

        const cabinets = [];
        const spacing = 6.5;
        const laneOffset = 5.5;
        const startZ = 11.5;

        games.forEach((game, index) => {
          const side = index % 2 === 0 ? 'left' : 'right';
          const cabinet = createCabinet(game, side, index);
          const x = side === 'left' ? -laneOffset : laneOffset;
          const z = startZ - index * spacing;
          cabinet.position.set(x, 0, z);
          cabinet.rotation.y = side === 'left' ? Math.PI / 2 : -Math.PI / 2;
          cabinetGroup.add(cabinet);

          const focusOffset = side === 'left' ? 2.8 : -2.8;
          cabinet.userData.focusPosition = new THREE.Vector3(x + focusOffset, 1.6, z + 1.2);

          cabinets.push(cabinet);
        });

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let hoverCabinet = null;
        let pendingHoverCabinet = null;
        let hoverLockState = 'idle';
        let hoverLockUntil = 0;
        const HOVER_LOCK_HOLD_MS = 500;
        const LOOK_TARGET_SETTLED_EPSILON = 0.05;
        let activeCabinet = null;
        let targetZ = cameraRig.position.z;
        let scrollVelocity = 0;
        const lastCabinetZ = startZ - (games.length - 1) * spacing;
        const minZ = lastCabinetZ - 4;
        const maxZ = 12;
        let scriptedMotion = null;
        const walkwayReturnPosition = new THREE.Vector3(0, 1.6, cameraRig.position.z);

        const emissivePulse = new THREE.Color(0x0ff0fc);
        const tempColor = new THREE.Color();

        window.addEventListener(
          'wheel',
          (event) => {
            if (activeCabinet || scriptedMotion) return;
            scrollVelocity += event.deltaY * 0.025;
          },
          { passive: true }
        );

        renderer.domElement.addEventListener('pointermove', (event) => {
          const rect = renderer.domElement.getBoundingClientRect();
          pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
          if (activeCabinet || scriptedMotion) return;
          raycaster.setFromCamera(pointer, camera);
          const intersects = raycaster.intersectObjects(cabinets, true);
          let candidate = intersects.length ? intersects[0].object : null;
          while (candidate && !cabinets.includes(candidate)) {
            candidate = candidate.parent;
          }
          pendingHoverCabinet = candidate && cabinets.includes(candidate) ? candidate : null;
          const now = performance.now();
          if (hoverLockState === 'idle') {
            applyHoverSelection(pendingHoverCabinet);
          } else if (hoverLockState === 'hold' && now >= hoverLockUntil) {
            hoverLockState = 'idle';
            applyHoverSelection(pendingHoverCabinet);
          }
        });

        renderer.domElement.addEventListener('pointerleave', () => {
          if (activeCabinet || scriptedMotion) return;
          pendingHoverCabinet = null;
          if (hoverLockState === 'idle') {
            applyHoverSelection(null);
          } else if (hoverLockState === 'hold' && performance.now() >= hoverLockUntil) {
            hoverLockState = 'idle';
            applyHoverSelection(null);
          }
        });

        renderer.domElement.addEventListener('click', () => {
          if (hoverCabinet && !activeCabinet && !scriptedMotion) {
            focusCabinet(hoverCabinet);
          }
        });

        closePanelButton.addEventListener('click', () => {
          exitCabinetView();
        });

        window.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            exitCabinetView();
          }
        });

        function focusCabinet(cabinet) {
          walkwayReturnPosition.set(0, 1.6, cameraRig.position.z);
          infoPanel.classList.remove('visible');
          const alignZ = THREE.MathUtils.clamp(cabinet.position.z, minZ, maxZ);
          const walkwayAlign = new THREE.Vector3(0, 1.6, alignZ);
          const forwardLookTarget = new THREE.Vector3(0, 1.6, alignZ - 8);
          const cabinetLookTarget = cabinet.position.clone().setY(2.4);
          const approachPosition = cabinet.userData.focusPosition.clone();

          startScriptedMotion(
            [
              { position: walkwayAlign, duration: 600, lookTarget: forwardLookTarget, lookLerpSpeed: 0.1 },
              { position: walkwayAlign, duration: 450, lookTarget: cabinetLookTarget, lookLerpSpeed: 0.16 },
              { position: approachPosition, duration: 700, lookTarget: cabinetLookTarget, lookLerpSpeed: 0.2 },
            ],
            {
              onComplete: () => {
                if (activeCabinet === cabinet) {
                  infoPanel.classList.add('visible');
                }
              },
            }
          );
          resetHoverState();
          activeCabinet = cabinet;
          infoTitle.textContent = cabinet.userData.game.name;
          infoDescription.textContent = cabinet.userData.game.description;
          playButton.href = cabinet.userData.game.url;
          renderer.domElement.style.cursor = 'default';
        }

        function exitCabinetView() {
          if (!activeCabinet) return;
          startScriptedMotion(walkwayReturnPosition, 900);
          activeCabinet = null;
          infoPanel.classList.remove('visible');
          renderer.domElement.style.cursor = 'default';
          targetZ = walkwayReturnPosition.z;
        }

        function startScriptedMotion(targetOrSteps, durationOrOptions) {
          let options = {};
          if (typeof durationOrOptions === 'number') {
            options.defaultDuration = durationOrOptions;
          } else if (durationOrOptions) {
            options = durationOrOptions;
          }

          const defaultDuration = options.defaultDuration ?? 900;

          const stepsSource = Array.isArray(targetOrSteps)
            ? targetOrSteps
            : [targetOrSteps];

          const toVector3 = (value) => {
            if (!value) return null;
            if (value.isVector3) return value.clone();
            if (typeof value.x === 'number' && typeof value.y === 'number' && typeof value.z === 'number') {
              return new THREE.Vector3(value.x, value.y, value.z);
            }
            return null;
          };

          const steps = stepsSource
            .map((step) => {
              if (!step) return null;
              if (step.isVector3) {
                return {
                  position: step.clone(),
                  duration: defaultDuration,
                  lookTarget: null,
                  lookLerpSpeed: null,
                };
              }

              const position = toVector3(step.position ?? step);
              if (!position) return null;

              return {
                position,
                duration: step.duration ?? defaultDuration,
                lookTarget: toVector3(step.lookTarget),
                lookLerpSpeed:
                  typeof step.lookLerpSpeed === 'number' ? step.lookLerpSpeed : null,
              };
            })
            .filter(Boolean);

          if (!steps.length) {
            scriptedMotion = null;
            return;
          }

          scriptedMotion = {
            steps,
            currentStep: 0,
            start: cameraRig.position.clone(),
            startTime: performance.now(),
            onComplete: options.onComplete ?? null,
          };

          scrollVelocity = 0;
        }

        function applyHoverSelection(cabinet) {
          if (hoverCabinet === cabinet) return;
          hoverCabinet = cabinet;
          if (hoverCabinet) {
            hoverLockState = 'panning';
            hoverLockUntil = 0;
          } else {
            hoverLockState = 'idle';
            hoverLockUntil = 0;
          }
          renderer.domElement.style.cursor = hoverCabinet ? 'pointer' : 'default';
        }

        function resetHoverState() {
          hoverCabinet = null;
          pendingHoverCabinet = null;
          hoverLockState = 'idle';
          hoverLockUntil = 0;
          renderer.domElement.style.cursor = 'default';
        }

        function updateCabinetEmissive() {
          const pulse = (Math.sin(performance.now() * 0.003) + 1) * 0.35 + 0.4;
          cabinets.forEach((cabinet) => {
            const screen = cabinet.getObjectByName('screen');
            if (!screen) return;
            if (cabinet === hoverCabinet && !activeCabinet) {
              screen.material.emissive = emissivePulse.clone().multiplyScalar(0.7);
            } else {
              tempColor.copy(emissivePulse).multiplyScalar(pulse * 0.6);
              screen.material.emissive = tempColor;
            }
          });
        }

        function createCabinet(game, side, index) {
          const cabinet = new THREE.Group();
          cabinet.userData.game = game;

          const bodyGeometry = new THREE.BoxGeometry(2.6, 3.8, 2.2);
          const bodyMaterial = new THREE.MeshStandardMaterial({
            color: side === 'left' ? 0x09122b : 0x1a0622,
            metalness: 0.4,
            roughness: 0.6,
            emissive: side === 'left' ? 0x053754 : 0x24032f,
            emissiveIntensity: 0.35,
          });
          const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
          body.position.y = 1.7;
          cabinet.add(body);

          const marqueeGeometry = new THREE.BoxGeometry(2.4, 0.6, 0.3);
          const marqueeMaterial = new THREE.MeshStandardMaterial({
            color: 0x0ff0fc,
            emissive: 0x0ff0fc,
            emissiveIntensity: 0.9,
          });
          const marquee = new THREE.Mesh(marqueeGeometry, marqueeMaterial);
          marquee.position.set(0, 3.5, 0.8);
          cabinet.add(marquee);

          const screenGeometry = new THREE.BoxGeometry(1.9, 1.4, 0.2);
          const screenMaterial = new THREE.MeshStandardMaterial({
            color: 0x05090f,
            emissive: 0x000000,
            emissiveIntensity: 0.8,
            transparent: true,
          });
          const screen = new THREE.Mesh(screenGeometry, screenMaterial);
          screen.position.set(0, 2.4, 1);
          screen.name = 'screen';
          cabinet.add(screen);

          textureLoader.load(
            game.thumbnail,
            (texture) => {
              texture.encoding = THREE.sRGBEncoding;
              texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
              const material = new THREE.MeshBasicMaterial({
                map: texture,
                toneMapped: false,
              });
              const imagePlane = new THREE.Mesh(new THREE.PlaneGeometry(1.8, 1.25), material);
              imagePlane.position.set(0, 2.4, 1.11);
              cabinet.add(imagePlane);
            },
            undefined,
            () => {
              // Texture failed to load; keep the emissive glow only.
            }
          );

          const panelGeometry = new THREE.BoxGeometry(2.2, 0.3, 1.2);
          const panelMaterial = new THREE.MeshStandardMaterial({
            color: 0x04070f,
            metalness: 0.3,
            roughness: 0.7,
          });
          const controlPanel = new THREE.Mesh(panelGeometry, panelMaterial);
          controlPanel.position.set(0, 1.2, 1.2);
          controlPanel.rotation.x = -Math.PI / 12;
          cabinet.add(controlPanel);

          const neonBaseGeometry = new THREE.BoxGeometry(3.2, 0.25, 2.8);
          const neonBaseMaterial = new THREE.MeshStandardMaterial({
            color: 0x03060d,
            emissive: 0x101a2c,
            emissiveIntensity: 0.4,
          });
          const base = new THREE.Mesh(neonBaseGeometry, neonBaseMaterial);
          base.position.y = 0.12;
          cabinet.add(base);

          const accentMaterial = new THREE.MeshBasicMaterial({
            color: side === 'left' ? 0x0ff0fc : 0xff4de1,
          });
          const accentGeometry = new THREE.CylinderGeometry(0.06, 0.06, 3.6, 12);
          const accent = new THREE.Mesh(accentGeometry, accentMaterial);
          accent.position.set(side === 'left' ? 1.35 : -1.35, 1.7, 0.95);
          accent.rotation.z = Math.PI / 2.5;
          cabinet.add(accent);

          return cabinet;
        }

        let lastFrameTime = performance.now();

        function animate() {
          requestAnimationFrame(animate);
          const now = performance.now();
          const deltaSeconds = Math.min((now - lastFrameTime) / 1000, 0.1);
          lastFrameTime = now;
          let forcedLookTarget = null;
          let forcedLookLerp = null;
          if (scriptedMotion) {
            const step = scriptedMotion.steps[scriptedMotion.currentStep];
            if (step) {
              const elapsed = now - scriptedMotion.startTime;
              const t = Math.min(elapsed / step.duration, 1);
              const eased = t >= 1 ? 1 : 1 - Math.pow(1 - t, 3);
              cameraRig.position.lerpVectors(scriptedMotion.start, step.position, eased);
              if (step.lookTarget) {
                forcedLookTarget = step.lookTarget;
              }
              if (typeof step.lookLerpSpeed === 'number') {
                forcedLookLerp = step.lookLerpSpeed;
              }
              if (t >= 1) {
                cameraRig.position.copy(step.position);
                scriptedMotion.currentStep += 1;
                if (scriptedMotion.currentStep >= scriptedMotion.steps.length) {
                  const onComplete = scriptedMotion.onComplete;
                  scriptedMotion = null;
                  if (typeof onComplete === 'function') {
                    onComplete();
                  }
                } else {
                  scriptedMotion.start = cameraRig.position.clone();
                  scriptedMotion.startTime = now;
                }
              }
            } else {
              const onComplete = scriptedMotion.onComplete;
              scriptedMotion = null;
              if (typeof onComplete === 'function') {
                onComplete();
              }
            }
          } else if (!activeCabinet) {
            const damping = Math.exp(-2.8 * deltaSeconds);
            scrollVelocity *= damping;
            if (Math.abs(scrollVelocity) < 0.00001) {
              scrollVelocity = 0;
            }
            targetZ += scrollVelocity * deltaSeconds;
            if (targetZ < minZ) {
              targetZ = minZ;
              scrollVelocity = Math.max(0, scrollVelocity);
            } else if (targetZ > maxZ) {
              targetZ = maxZ;
              scrollVelocity = Math.min(0, scrollVelocity);
            }
            cameraRig.position.z = THREE.MathUtils.lerp(cameraRig.position.z, targetZ, 0.08);
            cameraRig.position.x = THREE.MathUtils.lerp(cameraRig.position.x, 0, 0.08);
            cameraRig.position.y = THREE.MathUtils.lerp(cameraRig.position.y, 1.6, 0.08);
            walkwayReturnPosition.set(0, 1.6, cameraRig.position.z);
          }

          if (forcedLookTarget) {
            desiredLookTarget.copy(forcedLookTarget);
          } else if (activeCabinet) {
            desiredLookTarget.copy(activeCabinet.position).setY(2.4);
          } else if (hoverCabinet) {
            desiredLookTarget.copy(hoverCabinet.position).setY(cameraRig.position.y);
          } else {
            desiredLookTarget.set(0, 1.5, cameraRig.position.z - 10);
          }

          const lookLerpSpeed =
            typeof forcedLookLerp === 'number' ? forcedLookLerp : activeCabinet ? 0.2 : 0.08;
          lookTarget.lerp(desiredLookTarget, lookLerpSpeed);

          if (hoverLockState === 'panning' && hoverCabinet) {
            const lookDelta = lookTarget.distanceTo(desiredLookTarget);
            if (lookDelta < LOOK_TARGET_SETTLED_EPSILON) {
              hoverLockState = 'hold';
              hoverLockUntil = now + HOVER_LOCK_HOLD_MS;
            }
          } else if (hoverLockState === 'hold' && now >= hoverLockUntil) {
            hoverLockState = 'idle';
            applyHoverSelection(pendingHoverCabinet);
          }

          camera.lookAt(lookTarget);

          updateCabinetEmissive();

          renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });
      }
    </script>
  </body>
</html>
